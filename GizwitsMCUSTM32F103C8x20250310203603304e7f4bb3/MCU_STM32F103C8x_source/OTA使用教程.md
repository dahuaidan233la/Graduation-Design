# STM32F103C8x OTA使用教程

| 版本     | 修订内容 | 修订人 | 修订日期   |
| -------- | -------- | ------ | ---------- |
| OTA-V1.0 | 起稿     | 吴楚源 | 2023/02/03 |

[toc]

## OTA设计流程

该小节是向用户介绍程序中OTA的设计思路以及实现方法，用户简单了解即可，程序中已将OTA程序实现。如需快速使用，可直接跳转到下个小节：[**OTA的使用方法**](#OTA)。

### **简述** **STM32** **启动**

ARM7/ARM9 内核的控制器在复位后，CPU 会从存储空间的绝对地址 0x000000 取出第一条指令执行复位中断服务程序的方式启动，即固定了复位后的起始地址为 0x000000（PC = 0x000000）同时中断向量表的位置并不是固定的。然而，Cortex-M3 内核启动有 3 种情况：

1、 通过 boot 引脚设置可以将中断向量表定位于 SRAM 区，即起始地址为 0x2000000，同时复位后 PC 指针位于 0x2000000 处；

2、 通过 boot 引脚设置可以将中断向量表定位于 Flash 区，即起始地址为 0x8000000，同时复位后 PC 指针位于 0x8000000 处；

3、 通过 boot 引脚设置可以将中断向量表定位于内置 Bootloader 区；

Cortex-M3 内核规定，起始地址必须存放堆顶指针，而第二个地址则必须存放复位中断入口向量地址，这样在 Cortex-M3 内核复位后，会自动从起始地址的下一个 32 位空间取出复位中断入口向量，跳转执行复位中断服务程序。对比 ARM7/ARM9 内核，Cortex-M3 内核则是固定了中断向量表的位置而起始地址是可变化的。

总结一下 STM32 的启动文件和启动过程。首先对栈和堆的大小进行定义，并在代码区的起始处建立中断向量表，其第一个表项是栈顶地址，第二个表项是复位中断服务入口地址。然后在复位中断服务程序中跳转 C/C++标准实时库的 main 函数，完成用户堆栈等的初始化后，跳转.c 文件中的 main 函数开始执行 C 程序。假设 STM32 被设置为从内部 Flash 启动（这也是最常见的一种情况），中断向量表起始地位为 0x8000000，则栈顶地址存放于 0x8000000处，而复位中断服务入口地址存放于 0x8000004 处。当 STM32 遇到复位信号后，则从0x80000004 处取出复位中断服务入口地址，继而执行复位中断服务程序，然后跳转 main 函数，最后进入 mian 函数。

分析下 GOKIT_OTA 需求，我们将建立两个工程，分别是 Bootloader 还有 APP，我们将Bootloader 下载到 Flash 空间 0x8000000 地址处，那么 STM32 启动后会首先执行我们的Bootloader 程序，然后就可以按照我们意愿实现 OTA 了。

### <span id="click_me_jump">Flash区间划分</span>

根据需求，我们将 STM32F103C8T6 这个芯片Flash 空间划分出 4 个区域：Bootloader、FLAG、APP、APPBAK。四个区间作用描述如下：

- Bootloader:存储 Bootloader 固件，MCU 上电后首先运行该固件；
- FLAG:存储有关升级的相关标志位，Bootloader 和 APP 都需要操作该区域；
- APP：存储用户程序固件；
- APPBAK:临时存储云端下发的新固件，升级固件的一个过渡存储区；

  因为STM32F103C8T6 只有Flash 只有64K大小，所以分区方案如下图所示：

![1675419271491](image/OTA使用教程/1675419271491.png)

### OTA方案

**无升级任务时的执行流程：**

1. 上电进入 Bootloader 区域运行,检测 FLAG 区域标识是否需要进行升级，若无升级任务，则运行 2；
2. 跳转到 APP 区域运行应用程序；

**有升级任务时的执行流程：**

1. APP 区域运行应用程序时接收到模组升级命令，接收固件分片数据，写数据到APP_BAK 区域，接收完成，执行 2；
2. FLAG 区域写入升级标识，并写入 MD5 加密数据，执行 3；
3. MCU 重启，开始执行 4；
4. 进入 Bootloader 区域运行，检测到 FLAG 区域有升级任务，读出 APP_BAK 区域数据，验证固件有效性，若固件有效，执行 5；
5. 读出 APP_BAK 区域数据，写入 APP 区域，检验新固件 MD5，若校验成功则执行6，若校验失败，则 MCU 重启；
6. 擦除 FLAG 区域有效升级标志，执行 7；
7. MCU 重启，进入 Bootloader 区域,未检测到升级任务，执行 8；
8. 执行新固件，OTA 完成；

### Bootloader程序流程

Bootloader 的主要职能是在有升级任务的时候将 APPBAK 里面的固件拷贝到 APP 区域。当然，这期间需要做很多的工作，比如升级失败的容错等等。具体的流程可以参考图示。需要注意的是，**在校验 MD5 正确后开始搬运固件数据期间，MCU 出现故障（包括突然断电），MCU 应发生复位操作（FLAG 区域数据未破坏），复位后重新开始执行 Bootloader，从而避免 MCU 刷成板砖**。

![1675419293849](image/OTA使用教程/1675419293849.png)

### **APP接收程序流程**

APP 固件的编写要注意硬件版本号和软件版本号，软件版号是作为升级迭代很重要的标志。需要注意的是，中断向量地址偏移的定义，这个地方需要我们尤其注意，STM32 标准库默认中断向量地址偏移为 0x0,但是我们 APP 实际的偏移是 0x3000。如果不修改，APP 也可以正常加载运行，但是不会响应中断。所以，我们需要根据实际 APP 下载的起始地址，对中断向量地址偏移做定义。实现OTA数据接收的整个流程，具体如下：

![1675419312262](image/OTA使用教程/1675419312262.png)

## <span id="OTA">OTA的使用方法</span>

### 烧录Bootloader 固件

在该文档的同级目录下，有Bootloader 文件夹，该文件夹中的即是Bootloader 程序，用户使用Keil5打开程序，需要对工程做相应配置，需注意的是，OTA设计之初Bootloader 大小规划为11KB，所以Bootloader 固件大小不能超过最大可允许的 11KB。Keil 编译器需要设置如下：

1. 按照 Flash 分区方案，设置 Flash 固件下载地址。

   ![1675419625386](image/OTA使用教程/1675419625386.png)
2. Flash 烧写地址设置生效。

   ![1675419636691](image/OTA使用教程/1675419636691.png)
3. Jlink 下载按块擦除 Flash 区间。

![1675419646289](image/OTA使用教程/1675419646289.png)

以上配置完成之后即可编译烧录固件。

### 烧录APP固件

APP固件默认是屏蔽OTA功能的，如用户需要OTA功能，在烧录Bootloader固件之后需对APP固件做以下操作。

1. 打开OTA使能宏。

   ![1675419654602](image/OTA使用教程/1675419654602.png)
2. 根据需求更改中断向量表的偏移地址，若[Flash 区间划分](#click_me_jump)与本文档介绍的一样，则这一步直接跳过，不用改动。在关闭OTA使能宏时，中断向量表的偏移地址为0，开启OTA使能宏之后，中断向量表的偏移地址为0x3000（因为11K用于Bootloader，1K用于FLAG，所以中断向量表的偏移值为12KB*1024=0x3000）,若是APP固件太大，C8T6芯片的Flash不足以支持用户做OTA，那么用户可以选择外接Flash芯片，或者使用Flash 更大的芯片来实现OTA。

   ![1675419662278](image/OTA使用教程/1675419662278.png)
3. 按照Flash分区方案，设置Flash固件下载地址。

   ![1675419668347](image/OTA使用教程/1675419668347.png)
4. Flash烧写地址设置生效。

   ![1675419673884](image/OTA使用教程/1675419673884.png)
5. Jlink下载按块擦除 Flash 区间。

![1675419679189](image/OTA使用教程/1675419679189.png)

完成以上设置即可编译烧录APP固件，烧录完成之后此时通过日志可以发现，上电之后时候进入Bootloader，随后会在Bootloader中判断APP区固件是否正常，正常则跳转到APP区运行固件。

![1675419695417](image/OTA使用教程/1675419695417.png)

### 云端操作

在Bootloader固件和APP固件都烧录完成并成功运行之后，用户需让模组配网并使之连接云端后，才能在云端进行OTA操作，需要注意的是，**进行OTA的新固件的软件版本号必须比旧固件的软件版本号高**，例如旧固件的软件版本号为：03030000，则新固件的软件版本号为：03030001或更高。

![1675419705563](image/OTA使用教程/1675419705563.png)

云端具体操作如下：

1. 进入相应的云端产品，按下图操作进入OTA操作界面。

   ![1675419713567](image/OTA使用教程/1675419713567.png)
2. 在OTA设置界面里设置好参数之后，就可以生成固件包了。bin文件在文档同目录下的Output文件夹中（该目录需编译APP后才会生成）。

   ![1675419721201](image/OTA使用教程/1675419721201.png)
3. 生成固件包之后确认没问题点击验证固件包，随后设置要OTA的模组MAC，MAC可以在设备管理中查看。

   ![1675419727406](image/OTA使用教程/1675419727406.png)

   ![1675419733154](image/OTA使用教程/1675419733154.png)
4. 确认MAC地址之后，点击下一步，即可开始OTA。

   ![1675419742430](image/OTA使用教程/1675419742430.png)
5. 此时观察STM32日志可发现正在执行OTA操作。

![1675419750027](image/OTA使用教程/1675419750027.png)

![1675419759082](image/OTA使用教程/1675419759082.png)

此刻云端OTA界面让用户确认固件是否没问题，正确则点击确定。

![1675419767334](image/OTA使用教程/1675419767334.png)

至此，成功完成OTA！

## 自定义Flash OTA

当用户使用Flash较大的芯片，且APP固件超多26KB时，可自定义Flash区间划分，划分后需修改固件，具体操作如下：

1. 若用户使用自己编写的Bootloader，则烧录Bootloader时，需要在编译器修改Flash空间，修改大小为用户自己划分的区间。

   ![1675419774687](image/OTA使用教程/1675419774687.png)
2. 修改APP固件中对各个分区的Flash地址宏定义，修改大小为用户自己划分的区间。

   ![1675419781724](image/OTA使用教程/1675419781724.png)
3. 修改中断向量表地址偏移量，修改大小为用户自己划分的区间。

   ![1675419788938](image/OTA使用教程/1675419788938.png)
4. 烧录APP固件时，需要在编译器修改Flash烧写首地址和Flash烧写空间，修改大小为用户自己划分的区间

![1675419794756](image/OTA使用教程/1675419794756.png)

## Keil 生成 bin 文件

本方案只测试了 bin 文件的远程升级,hex 文件未作研究，所以我们需要通过 Keil 将我们的固件编译生成 bin 文件。Keil 自带了工具软件 fromelf.exe，只要进行适当配置便可以输出bin 文件了，至于 fromelf 工具语法在此不在赘述，可参考链接：http://forum.eepw.com.cn/thread/225710/1/

下面以 Gokit 微信宠物屋工程为例，编译后能生成.bin 格式的文件：

1. 选择 User 标签页，并进行如下图一样的配置：

   ![1675419803574](image/OTA使用教程/1675419803574.png)
2. 根据 User 页的配置还要配置 Output 页面，具体如下：

   ![1675419811228](image/OTA使用教程/1675419811228.png)
3. 点击 OK 确定，然后再重新编译则会按照上图中的配置路径生成.bin 格式的文件了：

![1675419820264](image/OTA使用教程/1675419820264.png)

## 合并 hex

本方案会编译生成两个 hex 文件，但是为方便用户下载，在此提供 hex 合并的操作，按照如下操作，我们可以将 bootloader 和 app 两个固件合并成一个固件，注意是 hex 格式文件，这样，用户只需要一个下载一个 hex 文件，即可实现带有远程 OTA 功能的微信宠物工程实现。

1. 准备好需要合并的 hex 文件，如下：

   ![1675419831231](image/OTA使用教程/1675419831231.png)
2. 开启 JFlash-ARM 工具. 打开第一个文件，顺序无所谓，因为 hex 文件自带地址信息，如下：

   ![1675419839863](image/OTA使用教程/1675419839863.png)
3. 点击 File 菜单, 选择 Merge data File，如下：

   ![1675419847665](image/OTA使用教程/1675419847665.png)
4. 保存合并后的 hex 文件，如下：

   ![1675419855331](image/OTA使用教程/1675419855331.png)
5. 生成目标文件，可以用 STMicroelectronics flash loader 下载

   ![1675419862494](image/OTA使用教程/1675419862494.png)
